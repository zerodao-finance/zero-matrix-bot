"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SynapseAdminApis = exports.SynapseRoomProperty = void 0;
const MatrixError_1 = require("./models/MatrixError");
/**
 * Available properties on a Synapse room listing to order by.
 * @category Admin APIs
 */
var SynapseRoomProperty;
(function (SynapseRoomProperty) {
    SynapseRoomProperty["Name"] = "name";
    SynapseRoomProperty["CanonicalAlias"] = "canonical_alias";
    SynapseRoomProperty["JoinedMembers"] = "joined_members";
    SynapseRoomProperty["JoinedLocalMembers"] = "joined_local_members";
    SynapseRoomProperty["Version"] = "version";
    SynapseRoomProperty["Creator"] = "creator";
    SynapseRoomProperty["Encryption"] = "encryption";
    SynapseRoomProperty["CanFederate"] = "federatable";
    SynapseRoomProperty["IsPublic"] = "public";
    SynapseRoomProperty["JoinRules"] = "join_rules";
    SynapseRoomProperty["GuestAccess"] = "guest_access";
    SynapseRoomProperty["HistoryVisibility"] = "history_visibility";
    SynapseRoomProperty["NumStateEvents"] = "state_events";
})(SynapseRoomProperty = exports.SynapseRoomProperty || (exports.SynapseRoomProperty = {}));
/**
 * Access to various administrative APIs specifically available in Synapse.
 * @category Admin APIs
 */
class SynapseAdminApis {
    constructor(client) {
        this.client = client;
    }
    /**
     * Get information about a user. The client making the request must be an admin user.
     * @param {string} userId The user ID to check.
     * @returns {Promise<SynapseUser>} The resulting Synapse user record
     */
    getUser(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.doRequest("GET", "/_synapse/admin/v2/users/" + encodeURIComponent(userId));
        });
    }
    /**
     * Create or update a given user on a Synapse server. The
     * client making the request must be an admin user.
     * @param {string} userId The user ID to check.
     * @param {SynapseUserProperties} opts Options to set when creating or updating the user.
     * @returns {Promise<SynapseUser>} The resulting Synapse user record
     */
    upsertUser(userId, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.doRequest("PUT", "/_synapse/admin/v2/users/" + encodeURIComponent(userId), undefined, opts);
        });
    }
    /**
     * Get a list of users registered with Synapse, optionally filtered by some criteria. The
     * client making the request must be an admin user.
     * @param {string} from The token to continue listing users from.
     * @param {number} limit The maximum number of users to request.
     * @param {string} name Optional localpart or display name filter for results.
     * @param {boolean} guests Whether or not to include guest accounts. Default true.
     * @param {boolean} deactivated Whether or not to include deactivated accounts. Default false.
     * @returns {Promise<SynapseUserList>} A batch of user results.
     */
    listUsers(from, limit, name, guests = true, deactivated = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const qs = { guests, deactivated };
            if (from)
                qs['from'] = from;
            if (limit)
                qs['limit'] = limit;
            if (name)
                qs['name'] = name;
            return this.client.doRequest("GET", "/_synapse/admin/v2/users", qs);
        });
    }
    /**
     * Get a list of all users registered with Synapse, optionally filtered by some criteria. The
     * client making the request must be an admin user.
     *
     * This method returns an async generator that can be used to filter results.
     * @param options Options to pass to the user listing function
     * @example
     * for await (const user of synapseAdminApis.listAllUsers()) {
     *    if (user.name === '@alice:example.com') {
     *       return user;
     *    }
     * }
     */
    listAllUsers(options = {}) {
        return __asyncGenerator(this, arguments, function* listAllUsers_1() {
            let from = undefined;
            let response;
            do {
                const qs = Object.assign(Object.assign({}, options), (from && { from }));
                response = yield __await(this.client.doRequest("GET", "/_synapse/admin/v2/users", qs));
                for (const user of response.users) {
                    yield yield __await(user);
                }
                from = response.next_token;
            } while (from);
        });
    }
    /**
     * Determines if the given user is a Synapse server administrator for this homeserver. The
     * client making the request must be an admin user themselves (check with `isSelfAdmin`)
     * @param {string} userId The user ID to check.
     * @returns {Promise<boolean>} Resolves to true if the user is an admin, false otherwise.
     * Throws if there's an error.
     */
    isAdmin(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.client.doRequest("GET", `/_synapse/admin/v1/users/${encodeURIComponent(userId)}/admin`);
            return response['admin'] || false;
        });
    }
    /**
     * Determines if the current user is an admin for the Synapse homeserver.
     * @returns {Promise<boolean>} Resolve to true if the user is an admin, false otherwise.
     * Throws if there's an error.
     */
    isSelfAdmin() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.isAdmin(yield this.client.getUserId());
            }
            catch (err) {
                if (err instanceof MatrixError_1.default && err.errcode === 'M_FORBIDDEN') {
                    return false;
                }
                throw err;
            }
        });
    }
    /**
     * Lists the rooms on the server.
     * @param {string} searchTerm A term to search for in the room names
     * @param {string} from A previous batch token to search from
     * @param {number} limit The maximum number of rooms to return
     * @param {SynapseRoomProperty} orderBy A property of rooms to order by
     * @param {boolean} reverseOrder True to reverse the orderBy direction.
     * @returns {Promise<SynapseRoomList>} Resolves to the server's rooms, ordered and filtered.
     */
    listRooms(searchTerm, from, limit, orderBy, reverseOrder = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = {};
            if (from)
                params['from'] = from;
            if (limit)
                params['limit'] = limit;
            if (searchTerm)
                params['search_term'] = searchTerm;
            if (orderBy)
                params['order_by'] = orderBy;
            if (reverseOrder) {
                params['dir'] = 'b';
            }
            else {
                params['dir'] = 'f';
            }
            return this.client.doRequest("GET", "/_synapse/admin/v1/rooms", params);
        });
    }
    /**
     * Gets a list of state events in a room.
     * @param {string} roomId The room ID to get state for.
     * @returns {Promise<any[]>} Resolves to the room's state events.
     */
    getRoomState(roomId) {
        return __awaiter(this, void 0, void 0, function* () {
            const r = yield this.client.doRequest("GET", `/_synapse/admin/v1/rooms/${encodeURIComponent(roomId)}/state`);
            return (r === null || r === void 0 ? void 0 : r['state']) || [];
        });
    }
    /**
     * Deletes a room from the server, purging all record of it.
     * @param {string} roomId The room to delete.
     * @returns {Promise} Resolves when complete.
     */
    deleteRoom(roomId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.doRequest("DELETE", `/_synapse/admin/v2/rooms/${encodeURIComponent(roomId)}`, {}, { purge: true });
        });
    }
    /**
     * Gets the status of all active deletion tasks, and all those completed in the last 24h, for the given room_id.
     * @param {string} roomId The room ID to get deletion state for.
     * @returns {Promise<any[]>} Resolves to the room's deletion status results.
     */
    getDeleteRoomState(roomId) {
        return __awaiter(this, void 0, void 0, function* () {
            const r = yield this.client.doRequest("GET", `/_synapse/admin/v2/rooms/${encodeURIComponent(roomId)}/delete_status`);
            return (r === null || r === void 0 ? void 0 : r['results']) || [];
        });
    }
    /**
     * List all registration tokens on the homeserver.
     * @param valid If true, only valid tokens are returned.
     * If false, only tokens that have expired or have had all uses exhausted are returned.
     * If omitted, all tokens are returned regardless of validity.

     * @returns An array of registration tokens.
     */
    listRegistrationTokens(valid) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.client.doRequest("GET", `/_synapse/admin/v1/registration_tokens`, { valid });
            return res.registration_tokens;
        });
    }
    /**
     * Get details about a single token.
     * @param token The token to fetch.
     * @returns A registration tokens, or null if not found.
     */
    getRegistrationToken(token) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.doRequest("GET", `/_synapse/admin/v1/registration_tokens/${encodeURIComponent(token)}`);
            }
            catch (e) {
                if ((e === null || e === void 0 ? void 0 : e.statusCode) === 404) {
                    return null;
                }
                throw e;
            }
        });
    }
    /**
     * Create a new registration token.
     * @param options Options to pass to the request.
     * @returns The newly created token.
     */
    createRegistrationToken(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.doRequest("POST", `/_synapse/admin/v1/registration_tokens/new`, undefined, options);
        });
    }
    /**
     * Update an existing registration token.
     * @param token The token to update.
     * @param options Options to pass to the request.
     * @returns The newly created token.
     */
    updateRegistrationToken(token, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.doRequest("PUT", `/_synapse/admin/v1/registration_tokens/${encodeURIComponent(token)}`, undefined, options);
        });
    }
    /**
     * Delete a registration token
     * @param token The token to update.
     * @returns A promise that resolves upon success.
     */
    deleteRegistrationToken(token) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.doRequest("DELETE", `/_synapse/admin/v1/registration_tokens/${encodeURIComponent(token)}`, undefined, {});
        });
    }
}
exports.SynapseAdminApis = SynapseAdminApis;
